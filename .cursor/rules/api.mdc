---
description: Typescript backend
globs: apps/**/*.ts
alwaysApply: true
---
# Backend API Architecture and Development Guidelines

You are an expert TypeScript backend engineer specializing in building modern, type-safe APIs. Your expertise covers Hono for HTTP routing, Drizzle ORM for database operations, and React Query for frontend integration.

## Core Architecture

### Technology Stack
- **Server & Routing**: Hono
- **Database ORM**: Drizzle with PostgreSQL
- **Frontend Integration**: React Query
- **Authentication**: Clerk
- **Validation**: Zod with zValidator

### Project Structure
apps/
  ├── api/
  │   ├── src/
  │   │   ├── modules/           # Feature-based modules
  │   │   │   ├── [module]/      # e.g., posts, webhooks
  │   │   │   │   ├── [module].routes.ts   # Route definitions
  │   │   │   │   └── [module].service.ts  # Business logic & DB operations
  │   │   ├── pkg/               # Shared utilities and middleware
  │   │   └── index.ts          # Main application setup
  └── web/
      └── src/
          └── api/
              └── [module].api.ts # React Query hooks

packages/
  └── db/
      ├── src/
      │   ├── schema.ts         # Database schema definitions
      │   ├── types.ts          # Shared TypeScript types
      │   ├── index.ts          # Main exports
      │   └── util/             # Database utilities

## Module Development Guidelines


### 1. Database layer
- If the request needs a new column or addition database fields start by creating and updating schema.ts
- Leverage types.ts inside packages/db to create new zod schemas for the newly created tables or columns and eg:
```
export type Post = InferSelectModel<typeof schema.posts>;
export type NewPost = InferInsertModel<typeof schema.posts>;

export const postInsertSchema = createInsertSchema(schema.posts).omit({ userId: true });
export const postSelectSchema = createSelectSchema(schema.posts);
```


### 2. Route Layer ([module].routes.ts)
- Define endpoints using Hono router
- Implement request validation using zValidator. You can leverage the created zod schemas from drizzle zod.
- Apply authentication middleware where needed
- Structure routes logically by resource
- Return consistent HTTP responses

Example route implementation:

const moduleRoutes = new Hono()
  .use(auth(),requireAuth)
  .get("/", async (c) => {
    const items = await moduleService.getItems();
    return c.json(items);
  })
  .post("/", zValidator("json", insertSchema), async (c) => {
    const data = c.req.valid("json");
    const userId = getUserId(c);
    const result = await moduleService.createItem({ ...data, userId });
    return c.json(result);
  });

### 3. Service Layer ([module].service.ts)
- Implement business logic
- Handle database operations using Drizzle
- Return strongly typed responses
- Keep services focused and modular

Example service implementation:

export const moduleService = {
  async getItems() {
    return db.select().from(items);
  },
  
  async createItem(data: NewItem) {
    return db.insert(items).values(data).returning();
  }
};



### 4. Frontend Integration ([module].api.ts)
- Define type-safe React Query hooks
- Implement proper error handling
- Use consistent query key patterns
- Handle loading and error states

Example React Query integration:

export function useItems() {
  return useQuery({
    queryKey: ['items'],
    queryFn: () => fetch('/api/items').then(res => res.json())
  });
}

export function useCreateItem() {
  return useMutation({
    mutationFn: (data: NewItem) => 
      fetch('/api/items', {
        method: 'POST',
        body: JSON.stringify(data)
      }).then(res => res.json())
  });
}

## Best Practices

### Type Safety
- Use Drizzle schemas for database types
- Use the 
- Share types between frontend and backend using a shared package
- Leverage zod for runtime validation

### Error Handling
- Implement consistent error handlers
- There is a catch all error handler alreaady implemented in error middleware
- Use proper HTTP status codes
- Return structured error responses
- Handle edge cases appropriately
- Use the logger from the package @repo/logger 

### Authentication & Authorization
- Use Clerk middleware for authentication
- Implement role-based access control where needed
- Validate user permissions at the route level
- Keep authentication logic in middleware

### API Design Principles
- Follow RESTful conventions
- Use consistent naming patterns
- Implement proper request validation
- Structure endpoints by resource/module
- Keep routes clean and delegate logic to services

### Database Operations
- Use Drizzle for all database interactions
- Implement proper migrations
- Handle transactions when needed
- Write efficient queries
- Use appropriate indexes

## Development Workflow

### Creating a New Module for different buisness logic
1. Create module directory in api/src/modules/[module]
2. Define routes in [module].routes.ts
3. Implement service logic in [module].service.ts
4. Add route to main application in index.ts
5. Create frontend integration in web/src/api/[module].api.ts

### Testing Requirements
- If needed use vitest to create testing files inside of the modules, [module].test.ts 


## Example Module Implementation

Here's a complete example of a typical module:

// posts.routes.ts
import { Hono } from "hono";
import { auth, requireAuth, getUserId } from "@/pkg/middleware/clerk-auth";
import { postService } from "./post.service";
import { zValidator } from "@/pkg/util/validator-wrapper";
import { postInsertSchema } from "@repo/db";

export const postRoutes = new Hono()
  .use(auth(),requireAuth)
  .get("/", async (c) => {
    const posts = await postService.getPosts();
    return c.json(posts);
  })
  .post("/", zValidator("json", postInsertSchema), async (c) => {
    const data = c.req.valid("json");
    const userId = getUserId(c);
    const post = await postService.createPost({ ...data, userId });
    return c.json(post);
  });

// posts.service.ts
import { db, posts, type NewPost } from "@repo/db";

export const postService = {
  async getPosts() {
    return db.select().from(posts);
  },

  async createPost(post: NewPost) {
    return db.insert(posts).values(post).returning();
  }
};

// posts.api.ts (Frontend)
- Use the RPC-style API client for type-safe API calls
- Leverage `InferRequestType` for parameter typing
- Export plain async functions for API operations
- Optionally create React Query hooks when needed

// posts.api.ts
import { apiRpc, getApiClient, InferRequestType } from "./client";

const $createPost = apiRpc.posts.$post;

export async function getPosts() {
  const client = await getApiClient();
  const response = await client.posts.$get();
  return response.json();
}

export async function createPost(params: InferRequestType<typeof $createPost>["json"]) {
  const client = await getApiClient();
  const response = await client.posts.$post({ json: params });
  return response.json();
}



